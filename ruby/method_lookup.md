# Method Lookup

Ruby中的方法查找发生在每天的编程中. 我们也经常听说到`向右一步, 再向上`的方法查找方式, 这是 *元编程*中提到的一种理解. 毕竟 *元编程*浅显易懂, 其中的大道理都一笔略过. 下面我们结合 *元编程* 走一遍方法查找. 方法查找有时候很让人很困惑, 但它却非常有规律. 理解复杂情况的最简单的方法就是将 Ruby 在后台创建的数据结构直观化.

每个 Ruby 对象(除了立即对象 immediate objects之外: Fixnums, symbols, true, false和 nil)在内存中都有一个`域`的集合:

- **klass**
    ```ruby
    指向这个对象的类对象的`指针`.(它是 klass而不是 class)
    ```
    这一句话有两层含义: 
    1. klass 是一个指针
    2. 而且总是指向这个对象的类对象
- **iv_tbl**
    instance_values_table "实例变量表", 是一个包含了属于此对象 *实例变量*信息的哈希表.
- **flags**
    一个数组, 含有一些状态信息的布尔值, 例如对象是否被污染(Dirty), 垃圾收集标记位(GC), 以及对象是否被冻结(frozen)等.

每个 Ruby **类或模块**不但具有上面的这些域, 还有另外两个域:

- **m_tbl**
    methods_table "方法表", 一个包含了类或者模块所有 *实例方法*信息的哈希表.
- **super**
    ```ruby
    指向此类或者模块的超类的`指针`
    ```
    这一句话有两层含义: 
    1. super 是一个指针
    2. 而且总是指向此类或者模块的超类

这些域在方法查找中扮演着重要的角色, 理解这些都非常必要. 

要特别指出的是, 你应该密切关注 **klass**与类对象的 **super**指针之间的区别. 

## 规则

方法查找规则非常简单, 但需要知道 Ruby数据结构是如何工作的. 当消息发送到一个对象时, 下面的这些步骤将会一次发生: 

1. Ruby根据接受者的 **klass** 指针指向的对象中搜索 *m_tbl* 中的方法并进行匹配. (klass指针的目标总是一个类对象)
2. 如果没有发现匹配的方法, Ruby 将根据此类对象的 *super* 指针在指向的












